'\"macro stdmacro
.if n .pH g3.random @(#)random	40.12 of 4/24/91
.\" Copyright 1991 UNIX System Laboratories, Inc.
.\" Copyright 1989, 1990 AT&T
.\" Copyright (c) 1983 Regents of the University of California.
.\" Copyright (c) 1988 Sun Microsystems, Inc. - All Rights Reserved.
.\"
.\" All rights reserved.  The Berkeley software License Agreement
.\" specifies the terms and conditions for redistribution.
.\"
.nr X
.if \nX=0 .ds x} random 3 "BSD Compatibility Package" "\&"
.if \nX=1 .ds x} random 3 "BSD Compatibility Package"
.if \nX=2 .ds x} random 3 "" "\&"
.if \nX=3 .ds x} random "" "" "\&"
.TH \*(x}
.SH NAME
\f4random\f1, \f4srandom\f1, \f4initstate\f1, \f4setstate\f1 \- better random number generator; routines for changing generators
.SH SYNOPSIS
\f4cc \f1[ \f2flag\f1\. \. \. ] \f2file\f1 \. \. \. \f4\-lucb\f1
.P
\f4long  random()\f1
.P
.nf
\f4srandom(seed)\f1
\f4int  seed;\f1
.fi
.P
.nf
\f4char  *initstate(seed, state, n)\f1
\f4unsigned  seed;\f1
\f4char  *state;\f1
\f4int  n;\f1
.fi
.P
.nf
\f4char  *setstate(state)\f1
\f4char  *state;\f1
.fi
.SH DESCRIPTION
.P
\f4random\f1
uses a non-linear additive feedback random number generator employing a
default table of size 31 long integers to return successive
pseudo-random numbers in the range from 0 to
.if t 2\u\s-231\s0\d\(mi\|1.
.if n (2**31)\(mi1.
The period of this random number generator is very large, approximately
.if t 16\(mu(2\u\s-231\s0\d\(mi\|1).
.if n 16*((2**31)\(mi1).
.P
\f4random\f1/\f4srandom\f1
have (almost) the same calling sequence and initialization properties as
\f4rand\f1/\f4srand\f1
[see \f4rand\f1(3C)].
The difference is that
\f4rand\f1(3C)
produces a much less random sequence\(emin fact, the low dozen bits
generated by rand go through a cyclic pattern.
All the bits generated by
\f4random\f1
are usable.
For example,
.IP
\f4random()&01\f1
.P
will produce a random binary value.
.P
Unlike
\f4srand\f1,
\f4srandom\f1
does not return the old seed because the amount of
state information used is much more than a single word.
Two other
routines are provided to deal with restarting/changing random number
generators.
Like
\f4rand\f1(3C),
however,
\f4random\f1
will, by default, produce a sequence of numbers that can be duplicated by calling
\f4srandom\f1 with
\f41\f1 as the seed.
.P
The \f4initstate\f1
routine allows a state array, passed in as an argument, to be
initialized for future use.
\f2n\f1 specifies the size of \f2state\f1 in bytes.
\f4initstate\f1 uses \f2n\f1
to decide how sophisticated a random number generator it should use\(emthe
more state, the better the random numbers will be.
Current ``optimal'' values for the amount of state information are 8, 32, 64,
128, and 256 bytes; other amounts will be rounded down to the nearest
known amount.
Using less than 8 bytes will cause an error.
The seed
for the initialization (which specifies a starting point for the random
number sequence, and provides for restarting at the same point) is also
an argument.
\f4initstate\f1
returns a pointer to the previous state information array.
.P
Once a state has been initialized, the
\f4setstate\f1
routine provides for rapid switching between states.
\f4setstate\f1
returns a pointer to the previous state array; its argument state array
is used for further random number generation until the next call to
\f4initstate\f1
or
\f4setstate\f1.
.P
Once a state array has been initialized, it may be restarted at a
different point either by calling
\f4initstate\f1
(with the desired seed, the state array, and its size) or by calling both
\f4setstate\f1
(with the state array) and
\f4srandom\f1
(with the desired seed).
The advantage of calling both
\f4setstate\f1
and
\f4srandom\f1
is that the size of the state array does not have to be remembered
after it is initialized.
.P
With 256 bytes of state information, the period of the random number
generator is greater than
.if t 2\u\s-269\s0\d,
.if n 2**69
which should be sufficient for most purposes.
.br
.ne 10
.SH EXAMPLE
.RS
.ft 4
.nf
/* Initialize an array and pass it in to initstate. */
.sp .25
static long state1[32] = {
	3,
	0x9a319039, 0x32d9c024, 0x9b663182, 0x5da1f342,
	0x7449e56b, 0xbeb1dbb0, 0xab5c5918, 0x946554fd,
	0x8c2e680f, 0xeb3d799f, 0xb11ee0b7, 0x2d436b86,
	0xda672e2a, 0x1588ca88, 0xe369735d, 0x904f35f7,
	0xd7158fd6, 0x6fa6f051, 0x616e6b96, 0xac94efdc,
	0xde3b81e0, 0xdf0a6fb5, 0xf103bc02, 0x48f340fb,
	0x36413f93, 0xc622c298, 0xf5a42ab8, 0x8a88d77b,
	0xf5ad9d0e, 0x8999220b, 0x27fb47b9
	};\f1
.sp .25
\f4main()
{
	unsigned seed;
	int n;\f1
.sp .25
\f4	seed = 1; 
	n = 128;
	initstate(seed, state1, n);\f1
.sp .25
\f4	setstate(state1);
	printf("%d\n",random());
}
.fi
.ft 1
.RE
.SH "SEE ALSO"
\f4rand\fP(3C)
.br
\f4drand48\fP(2),
\f4drand\f1(3C),
\f4rand\f1(3C),
\f4srand\f1(3C)
in the \f2Programmer's Reference Manual\f1
.SH "RETURN VALUE"
If
\f4initstate\f1
is called with less than 8 bytes of state information, or if
\f4setstate\f1
detects that the state information has been garbled, error messages are
printed on the standard error output.
.SH NOTES
About two-thirds the speed of \f4rand\f1(3C).
